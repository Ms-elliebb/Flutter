import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../domain/drawing_models.dart';
import '../domain/drawing_tool.dart';
import 'drawing_state.dart';

part 'drawing_notifier.g.dart'; // riverpod_generator için

/// Manages the state for the drawing feature using Riverpod for a specific room.
///
/// Holds the list of completed paths, the currently drawn path,
/// and the selected drawing tool settings (tool, color, stroke width) for one room.
@Riverpod(keepAlive: true)
class DrawingNotifier extends _$DrawingNotifier {
  /// Initializes the drawing state for a specific room.
  @override
  DrawingState build(String roomId) {
    // Print the room ID for debugging purposes when the notifier is built
    print("Building DrawingNotifier for room: $roomId");
    // Return the initial state with default tool, color, and width.
    return const DrawingState(); // Freezed defaults handle initialization
  }

  /// Selects the drawing tool (pen or eraser).
  void selectTool(DrawingTool tool) {
    state = state.copyWith(selectedTool: tool);
  }

  /// Selects the drawing color.
  void selectColor(Color color) {
    state = state.copyWith(selectedColorValue: color.value);
  }

  /// Selects the stroke width.
  void selectStrokeWidth(double width) {
    state = state.copyWith(selectedStrokeWidth: width);
  }

  /// Clears all paths from the canvas.
  void clearCanvas() {
    state = state.copyWith(paths: [], currentPath: null);
  }

  /// Starts a new drawing path at the given position using the current settings.
  ///
  /// If the eraser tool is selected, the path color will be set to white.
  void startPath(Offset startPoint) {
    final currentTool = state.selectedTool;
    final color =
        (currentTool == DrawingTool.eraser)
            ? Colors
                .white // Use background color for eraser
            : state.selectedColor;
    final strokeWidth = state.selectedStrokeWidth;

    final newPath = DrawingPath(
      points: [
        DrawingPoint(
          dx: startPoint.dx,
          dy: startPoint.dy,
          colorValue: color.value,
          strokeWidth: strokeWidth,
        ),
      ],
      colorValue: color.value,
      strokeWidth: strokeWidth,
    );
    state = state.copyWith(currentPath: newPath);
  }

  /// Adds a new point to the current drawing path.
  ///
  /// The point uses the color and stroke width already defined for the current path.
  void addPoint(Offset point) {
    if (state.currentPath == null) return; // No active path

    // Add the new point using the path's color and width
    // (already determined in startPath)
    final newPoint = DrawingPoint(
      dx: point.dx,
      dy: point.dy,
      colorValue: state.currentPath!.colorValue, // Use path's color
      strokeWidth: state.currentPath!.strokeWidth, // Use path's width
    );
    final updatedPoints = [...state.currentPath!.points, newPoint];

    // Use copyWith on DrawingPath (now generated by Freezed)
    state = state.copyWith(
      currentPath: state.currentPath!.copyWith(points: updatedPoints),
    );
  }

  /// Finalizes the current path and adds it to the list of completed paths.
  void endPath() {
    if (state.currentPath == null || state.currentPath!.points.length < 2) {
      // If path is null or has only one point, discard it
      state = state.copyWith(currentPath: null);
      return;
    }

    state = state.copyWith(
      paths: [...state.paths, state.currentPath!],
      currentPath: null, // Reset current path
    );

    // Firebase senkronizasyonu kaldırıldı
    // // TODO: Send the completed path to Firebase (next step)
  }

  // TODO: Add method for undo later
}
